3 Module M:
  4
  Value
    (non_rec, @.,
      [
        ((f, [ A; B ], [ (x, A) ], Monad ([ Type (OCaml.Failure) ], B)),
          Match
            ((?, Effect ([ Type (OCaml.Failure) ], .)),
              Variable ((?, Effect ([ ], .)), M/x),
              [
                (Any,
                  Apply
                    ((4,
                      Effect
                        ([
                          Type
                            (OCaml.Failure)
                        ],
                          .)),
                      Variable
                        ((4,
                          Effect
                            ([
                            ],
                              .
                                -[
                                  Type
                                    (OCaml.Failure)
                                ]->
                                .)),
                          OCaml.Pervasives.failwith),
                      [
                        Constant
                          ((4,
                            Effect
                              ([
                              ],
                                .)),
                            String("failure"))
                      ]))
              ]))
      ])

7 Module N:
  8
  Value
    (non_rec, @.,
      [
        ((f, [ A; B ], [ (x, A) ], Monad ([ Type (OCaml.Assert_failure) ], B)),
          Match
            ((?, Effect ([ Type (OCaml.Assert_failure) ], .)),
              Variable ((?, Effect ([ ], .)), N/x),
              [
                (Any,
                  Apply
                    ((8,
                      Effect
                        ([
                          Type
                            (OCaml.Assert_failure)
                        ],
                          .)),
                      Variable
                        ((8,
                          Effect
                            ([
                            ],
                              .
                                -[
                                  Type
                                    (OCaml.Assert_failure)
                                ]->
                                .)),
                          OCaml.assert),
                      [
                        Constructor
                          ((8,
                            Effect
                              ([
                              ],
                                .)),
                            false)
                      ]))
              ]))
      ])
  
  9
  Value
    (non_rec, @.,
      [
        ((x, [ ], [ ], Type (unit)),
          Match
            ((9, Effect ([ ], .)),
              Run
                ((?, Effect ([ ], .)), OCaml.Assert_failure,
                  [ ],
                  Apply
                    ((9,
                      Effect
                        ([
                          Type
                            (OCaml.Assert_failure)
                        ], .)),
                      Variable
                        ((9,
                          Effect
                            ([ ],
                              .
                                -[
                                  Type
                                    (OCaml.Assert_failure)
                                ]->
                                .)),
                          N/f),
                      [
                        Constructor
                          ((9,
                            Effect
                              ([
                              ],
                                .)),
                            tt)
                      ])),
              [
                (Constructor (inl, x),
                  Variable
                    ((?,
                      Effect
                        ([
                        ],
                          .)),
                      N/x));
                (Constructor (inr, Tuple (Any)),
                  Constructor
                    ((9,
                      Effect
                        ([
                        ],
                          .)),
                      tt))
              ]))
      ])
  
  10 Open M
  
  11
  Value
    (non_rec, @.,
      [
        ((y, [ ], [ ], Type (unit)),
          Match
            ((11, Effect ([ ], .)),
              Run
                ((?, Effect ([ ], .)), OCaml.Failure, [ ],
                  Apply
                    ((11,
                      Effect
                        ([ Type (OCaml.Failure) ],
                          .)),
                      Variable
                        ((11,
                          Effect
                            ([ ],
                              .
                                -[
                                  Type
                                    (OCaml.Failure)
                                ]->
                                .)),
                          M.f),
                      [
                        Constructor
                          ((11,
                            Effect
                              ([
                              ],
                                .)),
                            tt)
                      ])),
              [
                (Constructor (inl, x (= x_1)),
                  Variable
                    ((?,
                      Effect
                        ([
                        ],
                          .)),
                      N/x_1));
                (Constructor (inr, Tuple (Any)),
                  Constructor
                    ((11,
                      Effect
                        ([
                        ],
                          .)),
                      tt))
              ]))
      ])

14
Value
  (non_rec, @.,
    [
      ((b, [ ], [ ], Type (unit)),
        Match
          ((14, Effect ([ ], .)),
            Run
              ((?, Effect ([ ], .)), OCaml.Assert_failure, [ ],
                Apply
                  ((14, Effect ([ Type (OCaml.Assert_failure) ], .)),
                    Variable
                      ((14,
                        Effect
                          ([ ],
                            .
                              -[
                                Type
                                  (OCaml.Assert_failure)
                              ]-> .)), N.f),
                    [ Constructor ((14, Effect ([ ], .)), tt) ])),
            [
              (Constructor (inl, x), Variable ((?, Effect ([ ], .)), x));
              (Constructor (inr, Tuple (Any)),
                Constructor ((14, Effect ([ ], .)), tt))
            ]))
    ])

15 Open N

16
Value
  (non_rec, @.,
    [
      ((b', [ ], [ ], Type (unit)),
        Match
          ((16, Effect ([ ], .)),
            Run
              ((?, Effect ([ ], .)), OCaml.Assert_failure, [ ],
                Apply
                  ((16, Effect ([ Type (OCaml.Assert_failure) ], .)),
                    Variable
                      ((16,
                        Effect
                          ([ ],
                            .
                              -[
                                Type
                                  (OCaml.Assert_failure)
                              ]-> .)), N.f),
                    [ Constructor ((16, Effect ([ ], .)), tt) ])),
            [
              (Constructor (inl, x), Variable ((?, Effect ([ ], .)), x));
              (Constructor (inr, Tuple (Any)),
                Constructor ((16, Effect ([ ], .)), tt))
            ]))
    ])

18
Value
  (non_rec, @.,
    [ ((x, [ ], [ ], Type (Z)), Constant ((18, Effect ([ ], .)), Int(15))) ])

20 Module A:
  21
  Value
    (non_rec, @.,
      [
        ((x, [ A; B ], [ (x, A) ], Monad ([ Type (OCaml.Assert_failure) ], B)),
          Match
            ((?, Effect ([ Type (OCaml.Assert_failure) ], .)),
              Variable ((?, Effect ([ ], .)), A/x),
              [
                (Any,
                  Apply
                    ((21,
                      Effect
                        ([
                          Type
                            (OCaml.Assert_failure)
                        ],
                          .)),
                      Variable
                        ((21,
                          Effect
                            ([
                            ],
                              .
                                -[
                                  Type
                                    (OCaml.Assert_failure)
                                ]->
                                .)),
                          OCaml.assert),
                      [
                        Constructor
                          ((21,
                            Effect
                              ([
                              ],
                                .)),
                            false)
                      ]))
              ]))
      ])

24 Module B:
  25
  Value
    (non_rec, @.,
      [ ((a, [ ], [ ], Type (Z)), Variable ((25, Effect ([ ], .)), x)) ])
  
  26 Open A
  
  27
  Value
    (non_rec, @.,
      [
        ((b, [ A; B ], [ ], (A -> Monad ([ Type (OCaml.Assert_failure) ], B))),
          Variable
            ((27, Effect ([ ], . -[ Type (OCaml.Assert_failure) ]-> .)),
              A/x))
      ])
  
  28
  Value
    (non_rec, @.,
      [
        ((x, [ A; B ], [ (x, A) ], Monad ([ Type (OCaml.Failure) ], B)),
          Match
            ((?, Effect ([ Type (OCaml.Failure) ], .)),
              Variable ((?, Effect ([ ], .)), B/x),
              [
                (Any,
                  Apply
                    ((28,
                      Effect
                        ([
                          Type
                            (OCaml.Failure)
                        ],
                          .)),
                      Variable
                        ((28,
                          Effect
                            ([
                            ],
                              .
                                -[
                                  Type
                                    (OCaml.Failure)
                                ]->
                                .)),
                          OCaml.Pervasives.failwith),
                      [
                        Constant
                          ((28,
                            Effect
                              ([
                              ],
                                .)),
                            String("failure"))
                      ]))
              ]))
      ])
  
  29
  Value
    (non_rec, @.,
      [
        ((c, [ A; B ], [ ], (A -> Monad ([ Type (OCaml.Failure) ], B))),
          Variable
            ((29, Effect ([ ], . -[ Type (OCaml.Failure) ]-> .)), B/x))
      ])

32 Module C:
  33
  Value
    (non_rec, @.,
      [ ((a, [ ], [ ], Type (Z)), Variable ((33, Effect ([ ], .)), x)) ])
  
  34
  Value
    (non_rec, @.,
      [
        ((x, [ A; B ], [ (x, A) ], Monad ([ Type (OCaml.Failure) ], B)),
          Match
            ((?, Effect ([ Type (OCaml.Failure) ], .)),
              Variable ((?, Effect ([ ], .)), C/x),
              [
                (Any,
                  Apply
                    ((34,
                      Effect
                        ([
                          Type
                            (OCaml.Failure)
                        ],
                          .)),
                      Variable
                        ((34,
                          Effect
                            ([
                            ],
                              .
                                -[
                                  Type
                                    (OCaml.Failure)
                                ]->
                                .)),
                          OCaml.Pervasives.failwith),
                      [
                        Constant
                          ((34,
                            Effect
                              ([
                              ],
                                .)),
                            String("failure"))
                      ]))
              ]))
      ])
  
  35
  Value
    (non_rec, @.,
      [
        ((b, [ A; B ], [ ], (A -> Monad ([ Type (OCaml.Failure) ], B))),
          Variable
            ((35, Effect ([ ], . -[ Type (OCaml.Failure) ]-> .)), C/x))
      ])
  
  36 Open A
  
  37
  Value
    (non_rec, @.,
      [
        ((c, [ A; B ], [ ], (A -> Monad ([ Type (OCaml.Assert_failure) ], B))),
          Variable
            ((37, Effect ([ ], . -[ Type (OCaml.Assert_failure) ]-> .)),
              A.x))
      ])

40 Module D:
  41 Module A:
    42
    Value
      (non_rec, @.,
        [ ((a, [ ], [ ], Type (Z)), Constant ((42, Effect ([ ], .)), Int(2))) ])
  
  44
  Value
    (non_rec, @.,
      [ ((b, [ ], [ ], Type (Z)), Variable ((44, Effect ([ ], .)), x)) ])
  
  45 Open D/A
  
  46
  Value
    (non_rec, @.,
      [ ((c, [ ], [ ], Type (Z)), Variable ((46, Effect ([ ], .)), A/A.a)) ])
  
  47
  Value
    (non_rec, @.,
      [ ((d, [ ], [ ], Type (Z)), Variable ((47, Effect ([ ], .)), x)) ])
